\cutname{herd.html}

The tool \herd{} is a memory model simulator.
Users may write simple, single events,
axiomatic models of their own and run litmus tests on top
of their model.
The \herd{} distribution already includes some models.


The authors of~\herd{} are Jade Alglave and Luc Maranget.


\section{Writing simple models}

\subsection{Sequential consistency}
The simulator \herd{} accepts models written in text files.
For instance here is \afile{sc.cat},
the definition of the sequentially consistent (SC) model:
\verbatiminput{sc.cat}
The model above illustrate two features of model definitions:
\begin{enumerate}
\item The computation of new relations from other relations,
and their binding to a name with the \verb+let+ construct.
Here, a new relation \verb+com+ is the union ``\texttt{|}'' of
the three pre-defined communication relations.
\item The peformance of some checks. Here the relation ``\verb+po|com+''
(\emph{i.e.} the union of program order \textrel{po} and of  communication
relations) is required to be acyclic.
\end{enumerate}
We postpone the discussion of the \verb+show+ instruction, see
Sec.~\ref{sec:show}.

One can then run some litmus test, for instance \atest{SB}
(for \emph{Store Buffering},
see also Sec.~\ref{litmus:simple}), on top of the SC model:
\begin{verbatim}
% herd -model ./sc.cat SB.litmus
Test SB Allowed
States 3
0:EAX=0; 1:EAX=1;
0:EAX=1; 1:EAX=0;
0:EAX=1; 1:EAX=1;
No
Witnesses
Positive: 0 Negative: 3
Condition exists (0:EAX=0 /\ 1:EAX=0)
Observation SB Never 0 3
Hash=7dbd6b8e6dd4abc2ef3d48b0376fb2e3
\end{verbatim}
The output of \herd{} mainly consists in
the list of final states that are allowed by the simulated model.
Additional output relates to the test condition.
One sees that the test condition does not validate on top of SC,
as ``\texttt{No}'' appears just after the list of final states
and as there is no ``Positive'' witness.
Namely, the condition ``\verb+exists (0:EAX=0 /\ 1:EAX=0)+''
reflects a non-SC behaviour, see Sec.~\ref{candidate:intro}.

The simulator \herd{} works by generating all executions of a given test.
By ``execution'' we mean a choice of events,
program order~\textrel{po}, read-from~\textrel{rf},
and coherence orders \textrel{co}\footnote{The last communication relation from-read \textrel{fr}, derives
from \textrel{rf} and~\textrel{co}. A read event $r$ is \textrel{fr}-before
a write event $w$ when $r$ takes its value from a write $w_0$
that is \textrel{co}-before~$w$.}.
In the case of the \ltest{SB} example, we get the following four executions:
\begin{center}
\img{SB-00}\quad\quad
\img{SB-01}\quad\quad
\img{SB-02}\quad\quad
\img{SB-03}
\end{center}
Indeed, there is no choice for the program order \textrel{po}, as there are no
conditional jumps in this example; and  no choice for the coherence
orders \textrel{co} either, as there is only one store per location, which
must be \textrel{co}-after the initial stores (not pictured for clarity).
Then, there are two read events from locations $x$ and~$y$ respectively,
which take their values either from the initial stores or from
the stores in program. As a result, there are four possible executions.
The model \afile{sc.cat} gets executed on each of the four
(candidate) executions. The three first executions
are accepted and the last one is rejected, as it presents a cycle
in $\textrel{po} \cup \textrel{fr}$.
The following diagram pictures the \textrel{ghb} relation.
The cycle  is obvious:
\begin{center}\img{SB+SC}\end{center}

\subsection{Total Store Order (TSO)}
However, the non-SC execution \ahrefloc{x86:classic}{shows up} on x86 machines,
whose memory model is TSO. As TSO relaxes the write-to-read order, we attempt
to write a TSO model \afile{tso-00.cat}, by simply removing write-to-read
pairs from the acyclicity check:
\verbatiminput{tso-00.cat}
This model illustrates another feature of model definitions: filters
such as \verb+WW+ and~\verb+RM+ restrict their argument by selecting
some sort of events. As \verb+W+ stands for write events, \verb+R+ for
read events and \verb+M+ for all memory events, the effect of
\verb+let po-tso = WW(po)|RM(po)+ is to define \verb+po-tso+ as the program
order minus write-to-read pairs.

We run \atest{SB} on top of the tentative TSO model:
\begin{verbatim}
% herd -model tso-00.cat SB.litmus 
Test SB Allowed
States 4
0:EAX=0; 1:EAX=0;
0:EAX=0; 1:EAX=1;
0:EAX=1; 1:EAX=0;
0:EAX=1; 1:EAX=1;
Ok
Witnesses
Positive: 1 Negative: 3
...
\end{verbatim}
\label{sb:image}The non-SC behaviour is now accepted, as write-to-read \textrel{po}-pairs
do not participate to the acyclicity check any more. In effect, this allows
the \ahref{SB-03.png}{last execution} above,
as $\textrel{ghb}$ (\emph{i.e.}
$\textrel{po-tso} \cup \textrel{com-tso}$) is acyclic.
\begin{center}\img{SB+TSO}\end{center}


However,
our model \afile{tso-00.cat} is flawed: it is still to strict,
forbidding some behaviours that the TSO model should accept.
Consider the test \atest{SB+rfi-pos},
which is test \atest{STFW-PPC} for X86 from Sec.~\ref{stfw} with a normalised name (see Sec.~\ref{sec:names}).
This test targets the following execution:
\begin{center}\img{SB+rfi-pos}\end{center}
Namely the test condition
\verb+exists (0:EAX=1 /\ 0:EBX=0 /\ 1:EAX=1 /\ 1:EBX=0)+
specifies that Thread~$0$ writes~$1$ into location~$x$,
reads the value $1$~from the location~$x$ (possibly by store forwarding) and
then reads the value~$0$ from the location~$y$;
while Thread~$1$ writes~$1$ into~$y$,
reads~$1$ from~$y$ and then reads~$0$ from~$x$.
Hence, this test derives from the previour~\atest{SB}
by adding loads in the middle, those loads
being  satisfied from local stores.
As can be seen by running the test on top of the \afile{tso-00.cat}
model, the target execution is forbidden:
\begin{verbatim}
% herd -model tso-00.cat SB+rfi-pos.litmus 
Test SB+rfi-pos Allowed
States 15
0:EAX=0; 0:EBX=0; 1:EAX=0; 1:EBX=0;
...
0:EAX=1; 0:EBX=1; 1:EAX=1; 1:EBX=1;
No
Witnesses
Positive: 0 Negative: 15
..
\end{verbatim}
However, running the test with litmus demonstrates that the behaviour
is observed on some X86 machine:
\begin{verbatim}
% arch
x86_64
% litmus -mach x86 SB+rfi-pos.litmus
...
Test SB+rfi-pos Allowed
Histogram (4 states)
11589 *>0:EAX=1; 0:EBX=0; 1:EAX=1; 1:EBX=0;
3993715:>0:EAX=1; 0:EBX=1; 1:EAX=1; 1:EBX=0;
3994308:>0:EAX=1; 0:EBX=0; 1:EAX=1; 1:EBX=1;
388   :>0:EAX=1; 0:EBX=1; 1:EAX=1; 1:EBX=1;
Ok

Witnesses
Positive: 11589, Negative: 7988411
Condition exists (0:EAX=1 /\ 0:EBX=0 /\ 1:EAX=1 /\ 1:EBX=0) is validated
...
\end{verbatim}
As a conclusion, our tentative TSO model is too strong.
The following diagram pictures its \textrel{ghb} relation:
\begin{center}\img{SB+rfi-pos+TER}\end{center}
One easily sees that \textrel{ghb} is cyclic, wheras it should not.
Namely, the internal read-from relation~\textrel{rfi} does
not create global order in the TSO model.
Hence, \textrel{rfi} is not included in \textrel{ghb}.
We rephrase our tentative TSO model, resulting into the new model
\afile{tso-01.cat}:
\verbatiminput{tso-01.cat}
As can be observed above \textrel{rfi} (internal read-from) is no longer
included in \textrel{ghb}. However, \textrel{rfe} (external read-from)
still is.

As intended, this new tentative TSO model allows the behaviour of test~\atest{SB+rfi-pos}:
\begin{verbatim}
%  herd -model tso-01.cat SB+rfi-pos.litmus
Test SB+rfi-pos Allowed
States 16
...
0:EAX=1; 0:EBX=1; 1:EAX=1; 1:EBX=0;
...
Ok
Witnesses
Positive: 1 Negative: 15
...
\end{verbatim}
And indeed, the global-happens-before relation is no-longer cyclic:
\begin{center}\img{SB+rfi-pos+BIS}\end{center}


We are not done yet, as our model is too weak in two aspects.
First, it has no semantics for fences.
As a result the test \atest{SB+mfences} is allowed, whereas it should
be forbidden, as this is the very purpose of the fence \texttt{mfence}.
\begin{center}\img{SB+mfences}\end{center}
One easily solves this issue by adding the \verb+mfence+ relation
to the definition of \verb+po-tso+:
\begin{verbatim}
let po-tso = WW(po) | RM(po) | mfence
\end{verbatim}

But the resulting model is still too weak,
as it allows some behaviours that any model must
reject for the sake of single thread correctness.
The following test \atest{CoRWR} illustrates the issue:
\verbatiminput{CoRWR.litmus}
\begin{center}\img{CoRWR}\end{center}
The TSO check ``\verb+acyclic po-tso|com-tso+'' does not suffice to reject
two absurd behaviours pictured in the execution diagram above:
(1) the read~$a$ is allowed to
read from the \textrel{po}-after write~$b$, as \textrel{rfi} is not included
in \textrel{com-tso}; and~(2)
the read~$c$ is allowed to read the initial value of location~$x$
although
this (unpictured) write is \textrel{co}-before the write~$b$,
as \verb+WR(po)+ is not in \textrel{po-tso}.

\label{defuniproc}For any model, we rule out those very
untimely behaviours by the so-called
\textsc{uniproc}
check that states that executions projected on events that access one variable
only are SC.
In practice, having defined \verb+po-loc+ as \verb+po+ restricted to
events that touch the same address, we further require the acyclicity
of the relation \verb+po-loc|fr|rf|co+.
In the TSO case, the \textsc{uniproc}~check can be
somehow simplified by considering only
the cycles in \verb+po-loc|fr|rf|co+ that 
are not already rejected by the main check of the model.
This amounts to design specific checks for the two relations that are
not global in TSO: \verb+rfi+ and \verb+WR(po)+.
Doing so, we finally produce a correct model for TSO \afile{tso-02.cat}:
\verbatiminput{tso-02.cat}
This last model illustrates other features of \herd{}:
\herd{} may also performs irreflexivity checks with the keyword
``\verb+irreflexive+''; and
the checks can be given names by suffixing them with
``\texttt{as~}\textit{name}''.
This last feature will be used in Sec.~\ref{name:check}


\section{Producing pictures of executions}
The simulator \herd{} can be instructed to produce pictures of
executions.
Those pictures are instrumental in understanding and
debugging models.
It is important to understand that \herd{} does not produce pictures
by default. To get pictures one must instruct \herd{} to produce
pictures of some executions with the \opt{-show} option.
This option accepts specific keywords, its default being ``\opt{none}'',
instructing \herd{} not to produce any picture.

A frequentlty used keyword is ``\opt{prop}'' that means ``show the executions
that validate the proposition in the final condition''.
Namely, the final condition in litmus test is a quantified
boolean proposition as for instance ``\verb+exists (0:EAX=0 /\ 1:EAX=0)+'' at the end of test \atest{SB}.

But this is not enough, users also have to specify what to do with the picture:
save it in file in the DOT format of the
\ahref{http://graphviz.org/}{\prog{graphviz} graph visualization software}, or
display the image,\footnote{This option requires
the Postscript visualiser \ahref{\urlgv}{\prog{gv}}.} or both.
One instructs  \herd{} to save images with the \opt{-o }\textit{dirname} option,
where \textit{dirname} is the name of a directory, which must exists.
Then, when processing the file \textit{name}\texttt{.litmus},
\herd{} will create a file \textit{name}\texttt{.dot} into the
directory~\textit{dirname}.
For displaying images, one uses the \opt{-gv} option.

\label{sec:show}As an example,
so as to display the image of the non-SC behaviour of \atest{SB}, one
should invoke \herd{} as:
\begin{verbatim}
% herd -model tso-02.cat -show prop -gv SB.litmus
\end{verbatim}
\aname{sb:cluster}{As}
a result, users should see a window popping and displaying this image:
\begin{center}\img{SB+CLUSTER}\end{center}
Notice that we got the PNG version of this image as follows:
\begin{verbatim}
% herd -model tso-02.cat -show prop -o /tmp SB.litmus
% dot -Tpng /tmp/SB.dot -o SB+CLUSTER.png
\end{verbatim}
That is, we applied the \prog{dot} tool from the
\ahref{\urlgraphviz}{\prog{graphviz}} package, using the appropriate option
to produce a PNG image.

One may observe that there are \verb+ghb+ arrows in the diagram.
This results from the \verb+show ghb+ instruction
at the end of the model file~\afile{tso-02.cat}.

\subsection{Graph modes}
The image \ahrefloc{sb:cluster}{above} much differs from
the one in Sec.~\ref{sb:image} that describes the same execution
and that is reproduced in Fig.~\ref{fig:sb}
\begin{figure}
\caption{\label{fig:sb}The non-SC behaviour of \atest{SB} is allowed by TSO}
\begin{center}
\img{SB+TSO}
\end{center}
\end{figure}

\label{mode:example}In effect, \herd{} can produce three styles
of pictures, \prog{dot} clustered pictures, \prog{dot} free pictures,
and \prog{neato} pictures with explicit placement of the
events of one thread as a colum.
The style is commanded by the \opt{-graph} option that accepts three
possible arguments: \opt{cluster} (default), \opt{free} and~\opt{columns}.
The following pictures show
the effect of graph styles on the \atest{SB}~example:
\begin{center}
\begin{tabular}{*{3}{p{.25\linewidth}}}
\multicolumn{1}{c}{\opt{-graph cluster}} &
\multicolumn{1}{c}{\opt{-graph free}} &
\multicolumn{1}{c}{\opt{-graph columns}}\\
\img{SB+SQUISHED} \qquad &
\img{SB+FREE}\qquad &
\img{SB+COLUMNS}
\end{tabular}
\end{center}
Notice that we used another option \opt{-squished true} that much reduces
the information displayed in nodes. Also notice that
the first two pictures are formatted by \prog{dot},
while the rightmost picture is formatted by \prog{neato}.

One may also observe that the ``\opt{-graph columns}''  picture does not
look exactly like Fig.~\ref{fig:sb}. For instance the
\textrel{ghb} arrows are thicker in the figure.
There are many parameters to control \prog{neato} (and~\prog{dot}),
many of which are accessible to \herd{} users by the means of appropriate
options. We do not intend to describe them all.
However, users can reproduce the style of the diagram of this manual using
yet another feature of \herd: \ahrefloc{herd:configfile}{configuration files}
that contains settings for \herd{} options and that are loaded with the
\opt{-conf~}\textit{name} option.
In this manual we mostly used the \afile{doc.cfg} configuration file.
As this file is present in \herd{} distribution, users

can use the diagram style of this manual:
\begin{verbatim}
% herd -conf doc.cfg ...
\end{verbatim}

\subsection{\label{show:forbidden}Showing forbidden executions}
Images are produced or displayed once the model has been executed.
As a consequence,
forbidden executions won't appear by default.
Consider for instance the test \atest{SB+mfences},
where the \texttt{mfence} instruction is used to forbid
\atest{SB} non-SC execution. Runing \herd{} as
\begin{verbatim}
% herd -model tso-02.cat -conf doc.cfg -show prop -gv SB+mfences.litmus
\end{verbatim}
will produce no picture, as the TSO model forbids the target execution
of~\textsf{SB+mfences}.

To get a picture, we can run \textsf{SB+mfences} on top of the mininal
model, a pre-defined model that allows all executions:
\begin{verbatim}
% herd -model minimal -conf doc.cfg -show prop -gv SB+mfences.litmus
\end{verbatim}
And we get the picture:
\begin{center}\img{SB+mfences}\end{center}
It is worth mentioning again  that although the minimal model allows all
executions, the final condition
selects the displayed picture, as we have specified the
\opt{-show prop} option.


\label{name:check}The picture above shows \verb+mfence+ arrows, as all
fence relations are displayed by the minimal model.
However, it  does not show the \verb+ghb+ relation, as the minimal
model knows nothing of it.
To display~\verb+ghb+ we could write another model file that would be just as
\afile{tso-02.cat}, with checks erased.
The simulator \herd{} provides a simpler technique:
one can instruct \herd{} to ignore
either all checks (\opt{-through invalid}), or a selection of checks
(\opt{-skipcheck~}\textit{name$_1$}\ldots~\textit{name$_n$}).
Thus, either of the following two commands
\begin{verbatim}
% herd -through invalid -model tso-02.cat -conf doc.cfg -show prop -gv SB+mfences.litmus
% herd -skipcheck tso -model tso-02.cat -conf doc.cfg -show prop -gv SB+mfences.litmus
\end{verbatim}
will produce the picture we wish:
\begin{center}\img{SB+mfences+GHB}\end{center}
Notice that \verb+mfence+ and~\verb+ghb+ are displayed because
of the instruction ``\verb+show mfence ghb+'' (fence relation are not shown
by default);
while \opt{-skipcheck tso} works because the \afile{tso-02.cat} model
names its main check with ``\verb+as tso+''.

The image above is barely readable.
For such graphs with many relations, the \verb+cluster+ and~\verb+free+ modes
are worth a try. The commands:
\begin{verbatim}
% herd -skipcheck tso -model tso-02.cat -conf doc.cfg -show prop -graph cluster -gv SB+mfences.litmus
% herd -skipcheck tso -model tso-02.cat -conf doc.cfg -show prop -graph free -gv SB+mfences.litmus
\end{verbatim}
will produce the images:
\begin{center}
\begin{tabular}{p{.33\linewidth}@{\hspace*{6em}}p{.33\linewidth}}
\img{SB+mfences+CLUSTER}
&
\img{SB+mfences+FREE}
\end{tabular}
\end{center}
Namely, command line options are scanned left-to-right,
so that most of the settings of \afile{doc.cfg} are kept\footnote{The setting of \opt{showthread} is also changed, by the omitted \opt{-showthread true} command line option}
(for instance thick \verb+ghb+ arrows), while the graph mode is overriden.


\section{\label{herd:language}Model definitions}

We describe our langage for defining models.
The syntax of the language is given in BNF-like notation. Terminal
symbols are set in typewriter font (\synt{\T{like} \T{this}}).
Non-terminal symbols are set in italic font (\synt{\NT{like} \NT{that}}).
An unformatted vertical bar \synt{\ldots\orelse\ldots}
denotes alternative.
Square brackets \synt{\boption{}\ldots\eoption{}} denote optional components. Curly brackets
\synt{\brepet{}\ldots\erepet{}} denotes zero,
one or several repetitions of the enclosed
components.
%Parentheses \synt{\bparen{}\ldots\eparen{}} denote grouping.


Model source files may contain comments of the OCaml type
(\verb+(*+\ldots \verb+*)+, can be nested), or line comments starting with
``\verb+#+'' and running until end of line.

\subsection{\label{language:identifier}Identifiers}
\begin{syntax}
\NT{letter} \is \T{a} \ldots\T{z}
\orelse  \T{A} \ldots\T{Z}
\sep
\NT{digit} \is \T{0} \ldots\T{9}
\sep
\NT{id} \is \NT{letter} \brepet{} \NT{letter} \orelse \NT{digit}
\orelse \T{\_} \orelse \T{.} \orelse \T{-} \erepet
\end{syntax}
Identifiers are rather standard: they are a sequence of letters, digits,
``\texttt{\_}'' (the underscore character), ``\texttt{.}'' (the dot character)
and ``\texttt{-}'' (the minus character),
starting with a letter.
Using the minus character inside identifiers  may look a bit surprising.
We did so as to allow identifiers such as \texttt{po-loc}.

\label{sec:predef}At startup, pre-defined identifiers are bound to relations
between memory events. Those relations describe a candidate execution.
Executing the model means allowing or forbiding that candidate
execution.

A first pre-defined identifier is \tid{id}, the identity.
Other pre-defined identifiers are the program order
\tid{po} and its refinements:
\begin{idtable}
$\po$    & program order & instruction order lifted to events \\
$\poloc$ & \po{} restricted to the same address &
events are in \po{} and touch the same address\\
$\addr$ & address dependency & the address of the second event depends on
the value loaded by the first (read) event\\
$\data$ & data dependency & the value stored by the second (write)
event depends on
the value loaded by the first (read) event\\
$\ctrl$ & control dependency &
the second event is in a branch controled by the value loaded by the
commfirst (read) event\\
$\ctrlisync$/$\ctrlisb$ & control dependency + \isync/\isb{} &
the branch additionally contains a \isync/\isb{} barrier before
the second event\\
\end{idtable}
\bgroup\let\rln\tid
Other pre-defined relations denote the presence of a specific
fence (or barrier) in-between two events, those are
\mfence{}, \sfence, \lfence{} (X86);
\sync, \lwsync, \eieio, \isync{} (Power);
and \dsb, \dmb, \dsbst, \dmbst, \isb{} (ARM).
\egroup

Finally, pre-defined identifiers are bound the communication relations:
\begin{idtable}
$\rf$    & read-from     & links a write $w$ to a read $r$ taking its value from $w$ \\
$\co$    & coherence     & total order over writes to the same address \\
$\fr$    & from-read     & links a read $r$ to a write $w'$ $\co$-after the write $w$ from which $r$ takes its value \\
\rfi, \fri{}, \coi & internal communications &
communication between events of the same thread\\
\rfe, \fre{}, \coe & external communications &
communication between events of different threads
\end{idtable}

\subsection{\label{language:expression}Expressions}
Expressions are evaluated by \herd, yielding a relation over memory events
as a value.
A relation can be seen as a set of pairs of memory events.
\begin{syntax}
\NT{expr} \is{} \T{0}
\alt \NT{id}
\alt \NT{expr}\T{*} \orelse \NT{expr}\T{+} \orelse \NT{expr}\T{?}
\orelse \NT{expr}\T{\textasciicircum-1}
\alt \NT{expr}\T{|}\NT{expr} \orelse
\NT{expr}\T{;}\NT{expr} \orelse
\NT{expr}\T{\textbackslash}\NT{expr} \orelse
\NT{expr}\T{\&}\NT{expr}
\alt \NT{selector}\T{(}\NT{expr}\T{)}
\alt \NT{id} \T{(} \NT{args} \T{)}
\alt \T{fun} \T{(} \NT{params} \T{)} \T{->} \NT{expr}
\alt \T{let} \NT{binding} \brepet{} \T{and} \NT{binding} \erepet{} \T{in} \NT{expr}
\alt \T{let} \T{rec} \NT{valbinding} \brepet{} \T{and} \NT{valbinding} \erepet{} \T{in} \NT{expr}
\alt \T{(}\NT{expr}\T{)} \orelse  \T{begin} \NT{expr} \T{end}
\sep
\NT{selector} \is
\T{MM} \orelse
\T{MR} \orelse
\T{RM} \orelse
\T{MW} \orelse
\T{WM} \orelse
\T{RR} \orelse
\T{WR} \orelse
\T{RW} \orelse
\T{WW}
\alt
\T{AA} \orelse
\T{AP} \orelse
\T{PA} \orelse
\T{PP}
\alt
\T{ext} \orelse
\T{int} \orelse
\T{noid}
\sep
\NT{args} \is \epsilon
\alt \NT{expr} \brepet{} \T{,} \NT{expr} \erepet{}
\sep
\NT{params} \is \epsilon
\alt \NT{id} \brepet{} \T{,} \NT{id} \erepet{}
\sep
\NT{binding} \is \NT{valbinding} \orelse \NT{funbinding}
\sep
\NT{valbinding} \is \NT{id} \T{=} \NT{expr}
\sep
\NT{funbinding} \is \NT{id} \T{(} \NT{params} \T{)} \T{=} \NT{expr}
\sep
\end{syntax}

\subsubsection*{Simple expressions}
Simple expressions are the empty relation (keyword~\synt{\T{0}}) and
identifiers~\synt{\NT{id}}. Identifiers are bound to values, either
before the execution (see pre-defined identifiers in Sec.~\ref{sec:predef}),
or by the model itself.

\subsubsection*{Operator expressions}
The transitive and reflexive-transitive closure of an expression are performed
by the postfix operators \T{+} and~\T{*}.
The  postfix operator \T{\textasciicircum-1} performs relation inversion.
The construct \synt{\NT{expr}\T{?}} (option) evaluates to the union
of  \NT{expr} value and of the identity relation.

Infix operators are \T{|} (union), \T{;} (sequence), \T{\&} (intersection)
and \T{\textbackslash} (set difference).
The precedence of operators is as follows:
postfix operators bind tighter than infix operators.
Infix operators from higher precedence to lower precedence are:
\T{\&}, \T{\textbackslash}, \T{;} and~\T{|}.
All infix operators are right-associative,
except set difference which is left-associative.


For the record, given two relations $r_1$ and~$r_2$,
the sequence $r_1; r_2$ is defined
as $\{ (x,y) \mid \exists z, (x,z) \in r_1 \wedge (z,y) \in r_2\}$.

\subsubsection*{Selectors}
Selectors are filters that operate on relations.
The value of \synt{\NT{selector}\T{(}\NT{expr}\T{)}} is some subrelation
of the value of~\synt{\NT{expr}}. Which subrelation depends upon
\synt{\NT{selector}}.

Most selectors are two-letters keywords
with the first letter operating on the first component of pairs and
the second letter operating on the second component of pairs.
More precisely, we define the semantics of selector letters as
predicates over memory events: \T{M} always yield true,
\T{R} yields true on read events,
\T{W} yields true on write events,
\T{A} yields true on atomic events (produced by X86 locked instructions,
or ARM/Power load reserve and store conditional instructions),
and \T{P} yields true on ordinary (plain) events.
Then, we define:
$$
XY(r) = \{ (x,y) \in r \mid X(x) \wedge Y(y)\}
$$
For instance, the expression \verb+RW(po)+ yields the read-to-write pairs
in program order.

Three additional selectors \synt{\T{ext}}, \synt{\T{int}}, and \synt{\T{noid}}
performs specific operations.
The first selects pairs of events in different threads (``external''),
the second selects pairs of events in the same thread (``internal''),
and the third selects pairs of events that are different (``not identical'').

\subsubsection*{Function calls}
Functions calls are written
\synt{\NT{id}\T{(}\NT{expr}_1 \T{,} \ldots \T{,} \NT{expr}_n\T{)}}.
That is, functions have an arity ($n$ above, which can be zero)
and arguments are given as a comma separated list of expressions.
Our language have call-by-value semantics. That is,
the effective parameters
\synt{\NT{expr}_1 \T{,} \ldots \T{,} \NT{expr}_n} are evaluated before
being bound to formal parameters.

\subsubsection*{Functions}
Functions are first class values, as reflected by the anonymous
function construct \synt{\T{fun} \T{(} \NT{params} \T{)} \T{->} \NT{expr}}.
Function arity is defined by the length of its formal parameter list
\synt{\NT{params}}, which can be empty.
Notice that functions have the usual static scoping semantics:
variables that appear free in function bodies 
(\synt{\NT{expr}} above) are bound to
the value of such free variable at function creation time.


\subsubsection*{\label{bindings}Local bindings}
The local binding construct
\synt{\T{let} \boption{} \T{rec} \eoption{} \nt{bindings} \T{in} \NT{expr}}
binds the names defined by \nt{bindings} 
for evaluating the expression \NT{expr}.

Both non-recursive and recursive bindings are allowed.
The function binding
\synt{\NT{id} \T{(} \NT{params} \T{)} \T{=} \NT{expr}} is syntactic sugar
for \synt{\NT{id} \T{=} \T{fun} \T{(} \NT{params} \T{)} \T{->} \NT{expr}}.
It is allowed in non-recursive bindings only as there is little point
in defining recursive function in our setting.

In the following we only consider value bindings \synt{\NT{id} \T{=} \NT{expr}}.
The construct
\begin{center}
\synt{\T{let} \NT{id}_1 \T{=} \NT{expr}_1 \T{and} \ldots \T{and} \NT{id}_n \T{=} \NT{expr}_n} \T{in} \NT{expr}
\end{center}
evaluates \synt{\nt{expr}_1,\ldots, \nt{expr}_n},
and binds the names  \synt{\nt{id}_1,\ldots, \nt{id}_n} to the resulting values.

\aname{letrec}{The} construct
\begin{center}
\synt{\T{let} \T{rec} \NT{id}_1 \T{=} \NT{expr}_1 \T{and} \ldots \T{and} \NT{id}_n \T{=} \NT{expr}_n} \T{in} \NT{expr}
\end{center}
computes the least fixpoint of the equations
$\nt{id}_1 = \nt{expr}_1$,\ldots, $\nt{id}_n = \nt{expr}_n$.
It then binds the names \synt{\nt{id}_1,\ldots, \nt{id}_n} to the
resulting values.
The least fixpoint computation applies only to relations, using
inclusion for ordering.
Notice that
\synt{\T{let} \T{rec} \NT{id} \T{=} \T{fun} \T{(} \NT{params} \T{)} \T{->} \NT{expr} \T{in}\ldots} is legal syntax. Such a definition will yield
a runtime error.

\subsubsection*{Parenthesised expressions}
The expression \synt{\T{(}\NT{expr}\T{)}}
has the same value as \synt{\NT{expr}}.
Notice that a parenthesised expression
can also be written as  \synt{\T{begin} \NT{expr} \T{end}}.

\subsection{\label{language:instruction}Instructions}
Instruction are executed for their  effect.
There are three kind of effects: adding new bindings,
checking a condition, and specifying relations that are shown in pictures.
\begin{syntax}
\NT{instruction} \is{} \T{let} \NT{binding} \brepet{} \T{and} \NT{binding} \erepet{}
\alt \T{let} \T{rec} \NT{valbinding} \brepet{} \T{and} \NT{valbinding} \erepet{}
\alt \NT{check} \NT{expr} \boption \T{as} \NT{id}\eoption
\alt \T{procedure} \NT{id} \T{(} \NT{params} \T{)} \T{=} \brepet \NT{instruction} \erepet \T{END}
\alt \T{call} \NT{id} \T{(} \NT{args} \T{)}
\alt \T{show} \NT{expr} \T{as} \NT{id}
\alt \T{show} \NT{id} \brepet \T{,} \NT{id} \erepet
\alt \T{unshow} \NT{id} \brepet \T{,} \NT{id} \erepet
\alt \T{include} \nt{string}
\sep
\NT{check} \is \T{acyclic} \orelse \T{irreflexive} \orelse \T{empty}
\end{syntax}

\subsubsection*{Bindings}
The \T{let} and \T{let}~\T{rec} constructs bind value names for the rest
of model execution.
See the subsection on \ahrefloc{bindings}{bindings}
in Section~\ref{language:expression}
for additional information on the syntax and semantics of bindings.


Recursive definitions computes fixpoints of relations.
For instance, the following fragment computes the transitive closure of
all communication relations:
\begin{verbatim}
let com = rf | co | fr
let rec complus = com | (complus ; complus)
\end{verbatim}
Notice that the instruction \verb-let complus = (rf|co|fr)+- is equivalent.

%Notice that \herd{} assumes that recursive definitions are well-formed,
%\emph{i.e.} that they yield an increasing functional.
%The result of ill-formed definitions is undefined.

There are no recursive functions, as those would not be very useful in
our limited language. Nevertheless, one may for instance
write a generic transitive closure
function by using a local recursive binding:
\begin{verbatim}
let tr(r) = let rec t = r | (t;t) in t
let complus = tr(rf|co|fr)
\end{verbatim}
Again notice that the instruction
\verb-let complus = (rf|co|fr)+- is equivalent.

\subsubsection*{\aname{sec:check}{Checks}}
The construct
\begin{center}\synt{\NT{check} \NT{expr}}\end{center}
evaluates \nt{expr} and applies \nt{check}.
If the check succeeds, that is if the relation is acyclic, irreflexive
or empty; depending on \nt{check} being \T{acyclic}, \T{irreflexive}
or \T{empty}, execution goes on. Otherwise, execution stops.

\label{name:check:def}The performance of a
check can optionally be named  by appending
\synt{\T{as} \NT{id}} after it.
The feature permits not to perform some checks at user's will,
thanks to the \ahrefloc{skipcheck}{\opt{-skipcheck~}\nt{id}}
command line~option.


\subsubsection*{Procedure definition and call}
Procedures are similar to functions except that they have no results:
the body of a procedure is a list of instructions
and the procedure will be called for the effect of executing
those instructions. Intended usage of procedures is to define checks
that are executed later. However, the body of a procedure may
consist in any kind of instructions.

For instance, one may define the following \verb+uniproc+ procedure with
no arguments:
\begin{verbatim}
procedure uniproc() =
  let com = fr | rf | co in
  acyclic com | po
\end{verbatim}
Then one can perform the acyclicity check (see
\ahrefloc{sec:check}{previous section}) by executing the instruction:
\begin{verbatim}
call uniproc()
\end{verbatim}
As a result the execution will stop if the acyclicity check fails,
or continue otherwise.


Procedures are lexically scoped as functions are.
Additionally, the bindings performed during the execution of a procedure call
are discarded when the procedure returns, all other effects performed are
retained.

\subsubsection*{Show (and unshow) directives}
\label{show:def}The constructs:
\begin{center}
\synt{\T{show} \NT{id} \brepet \T{,} \NT{id} \erepet}\quad{and}\quad\synt{\T{unshow} \NT{id} \brepet \T{,} \NT{id} \erepet}
\end{center}
take (non-empty, comma separated) lists of identifiers as arguments.
The \T{show} construct adds the present values of identifiers for being
shown in pictures.
The \T{unshow} construct removes the identifiers from shown relations.

The more sophisticated construct
\begin{center}\synt{\T{show} \NT{expr} \T{as} \NT{id}}\end{center}
evaluates \nt{expr} to a relation, which will be shown in pictures with
label~\nt{id}.
Hence  \synt{\T{show} \nt{id}} can be viewed as a shorthand
for \synt{\T{show} \nt{id} \T{as} \nt{id}}

\subsubsection*{Model inclusion}
The construct \synt{\T{include} \T{"}\nt{filename}\T{"}} is interpreted as
the inclusion of the model contained in the file whose name is given as
an argument to the \synt{\T{include}} instruction.
In practice the list of intructions defined by the included model file
are executed.
The string argument is delimited by double quotes ``\verb+"+'',
which, of course, are not part of the filename.


Notice that:
\begin{itemize}
\item Files are searched according to \herd{} rules --- see Sec.~\ref{herd:searchpath}.
\item Model options defined in the model file \synt{\nt{filename}} are ignored.
\end{itemize}


\subsection{\label{language:model}Models}
\begin{syntax}
\NT{model} \is \NT{model-comment}  \brepet \NT{model-option} \erepet \brepet \NT{instruction} \erepet
\sep
\NT{model-comment} \is \NT{id} \orelse  \nt{string}
\sep
\NT{model-option} \is \T{withco} \orelse \T{withoutco}
\orelse \T{withinit} \orelse \T{withoutinit}
\end{syntax}
A model is a a list of instruction preceded by a small comment,
which can be either a name that follows \herd{} conventions for identifiers,
or a string enclosed in double quotes~``\verb+"+'',
and a list of options.

Models operate on candidate executions
(see Sec.~\ref{sec:predef}),
instructions are executed in sequence,
until one instruction stops, or until the end of the instruction list.
In that latter case, the model accepts the execution.
The accepted execution is then passed over to the rest of \herd{}
engine, in order to collect final states of locations
and to display pictures.

\subsubsection*{Model options}

Model options control some experimental features of \herd.
More precisely, by default, \herd{} includes a complete
coherence order relation in every candidate execution,
and does not represent initial writes by plain memory
write events. Said otherwise, by default,
model files have options \T{withco} and \T{whithoutinit}.

The generation of all possible coherence orders by \herd{} engine
is a source of inefficiency that can be alleviated by having the
model itself compute the sub-relation of \texttt{co} that is really useful.
Such models must have option \T{withoutco}, so as to
prevent \herd{} engine from generating all coherence orders.
Instead, \herd{} will represent initial writes as plain write events
(\emph{i.e.} option \T{withoutco} implies \T{withinit})
identify last writes in coherence oders, and pass the model a
reduced~\texttt{co} relation, named \texttt{co0}, that will,
for any memory location~$x$,
relate the initial write to~$x$ to all writes to~$x$, and all writes
to~$x$ to the final write to~$x$.
It is then the model responsability  to compute the remainder
of \texttt{co} from the program read events.
The model \ahref{uniproccat.txt}{\texttt{uniproccat.cat}} from the distribution
gives an example of such an advanced model.

The option \T{withinit} can also be given alone so as to instruct
\herd{} engine to represent initial writes as plain write events.
In such a situation, \herd{} will compute complete coherence
orders~\texttt{co} that include those explicit initial writes as
minimal elements.
Observe that the representation of initial writes as events
can be also controlled from the
command-line (see option~\ahrefloc{opt:initwrites}{\opt{-initwrites}})
and that command line settings override model options.

\section{Usage of \herd}

\subsection{Arguments}
The command \herd{} handles its arguments like \litmus.
That is, \herd{} interprets its argument as file names.
Those files are either a single litmus test
when having extension \file{.litmus}, or a list of file names
when prefixed by \file{@}.


\subsection{Options}
There are many command line options.
We describe the more useful ones:

\paragraph*{General behaviour}
\begin{description}
\item[{\tt -version}] Show version number and exit.
\item[{\tt -libdir}] Show installation directory and exit.
\item[{\tt -v}] Be verbose, can be repeated to increase verbosity.
\item[{\tt -q}] Be quiet, suppress any diagnostic message.
\item[{\tt -conf <name>}] Read configuration file~\opt{name}.
\ahrefloc{herd:configfile}{Configuration files} have a very simple syntax:
a line ``\textit{opt}\texttt{  }\textit{arg}'' has the same effect as
the command-line option ``\texttt{-}\textit{opt} \textit{arg}''.
\item[{\tt -o <dest>}] Output files into directory \opt{<dest>}.
Notice that \opt{<dest>} must exist.
At the moment \herd{} may output one \texttt{.dot} file per processed test:
the file for test \textit{base}\texttt{.litmus}
is named  \textit{base}\texttt{.dot}.
By default \herd{} does not generate \texttt{.dot} files.
\item[{\tt -suffix <suf>}] Change the name of \texttt{.dot} files
into \textit{base}\textit{suff}\texttt{.dot}. Useful when several \texttt{.dot} files derive from the same test. Default is the empty string (no suffix).
\item[{\tt \aname{opt:gv}{-gv}}] Fork the \ahref{\urlgv}{\prog{gv} Postscript viewer} to display execution diagrams.
\item[{\tt -dumpes <bool>}]
Dump genererated event structures and exit. Default is \opt{false}.
Event structures will be dumped in a \texttt{.dot} file whose
name is determined as usual --- See options \opt{-o} and \opt{-suffix} above.
Optionally the event structures can be displayed with the \opt{-gv} option.
\item[{\tt -unroll <int>}] The setting \opt{-unroll }$n$ performs backwards
jumps $n$ times. This is a workaround for one of \herd{} main limitation:
\herd{} does not really handle loops. Default is~\opt{2}.
\item[{\tt -hexa <bool>}] Print numbers in hexadecimal. Default is \opt{false}
(numbers are printed in decimal).
\end{description}

\paragraph{Engine control}
The main purpose of \herd{} is to run tests on top of memory models.
For a given test, \herd{} performs a three stage process:
\begin{enumerate}
\item Generate candidate executions.
\item For each exection, run the model. The model may reject or accept
the execution.
\item For each candidate that the model accepts, record observed locations
and a diagram of the execution (if instructed so).
\end{enumerate}
We now describe options that control those three stages.

\begin{description}
\item[{\tt -model (herd|cav12|minimal|uniproc|x86tso|<filename>.cat)}]
Select model, this option accept one tag or one file name
with extension~\texttt{.cat}.
Tags instruct \herd{} to select an internal model,
while file names are read for a model definition.
By default, \herd{} run tests on top of an advanced (\opt{herd})
model for Power and~ARM,
and on top of \opt{x86tso} for X86.
Other (documented) model tags are:
\begin{itemize}
\item \opt{cav12}, the model of~\cite{mms12} (Power);
\item \opt{minimal}, the minimal model that allows all executions;
\item \opt{uniproc}, the uniproc model that checks single-thread correctness.
\end{itemize}

In fact, \herd{} accepts potentially infinitely many models,
as models can given in text files in an adhoc language described in
Sec.~\ref{herd:language}.
The \herd{} distribution includes several such models:
\afile{herd.cat}, \afile{minimal.cat}, \afile{uniproc.cat}
and \afile{x86tso.cat} are
text file versions of the homonymous internal models, but may
produce pictures that show different relations.
Model files are searched according to  the same
\ahrefloc{herd:searchpath}{rules}
as configuration files.

\item[{\tt -through (all|invalid|none)}]
Let additional executions reach the final stage of \herd{} engine.
This option permits users to generate pictures of forbidden executions, which
are otherwise rejected at an early stage of \herd{} engine --- see Sec.~\ref{show:forbidden}.
Namely, the default~``\opt{none}'' let only valid (according to the
active model) executions through.
The behaviour of this option differs between internal and text file models:
\begin{itemize}
\item For internal models:
the tag~\opt{all} let all executions go through;
while the tag~\opt{invalid} will reject executions that violate uniproc,
while letting other forbidden execution go through.
\item Text file models: the tags \opt{all} and~\opt{invalid} let all
executions go through. For such models, a more precise control over
executions that reach \herd{} final phase can be achieved
with the option~\opt{-skipcheck} --- see  next option.
\end{itemize}
Default is~\opt{none}.

\item[{\tt -skipcheck <\textit{name}$_1$,\ldots,\textit{name}$_n$>}]
\aname{skipcheck}{This option} applies to text file models. It instructs \herd{} to ignore
the outcomes of the given checks. For the option to operate, checks must
be named in the model file with the \texttt{as }\textit{name} construct --
see Sec.~\ref{name:check:def}.
Notice that the arguments to \opt{-skipcheck} options cumulate.
That is, ``\opt{-skipcheck }\textit{name}$_1$ \opt{-skipcheck }\textit{name}$_2$'' acts like ``\opt{-skipcheck }\textit{name}$_1$\texttt{,}\textit{name}$_2$''. 

\item [{\tt -strictskip <bool>}] Setting this option (\opt{-strictskip true}),
will change the behaviour of the previous option \opt{-skipcheck}:
it will let executions go through when the skipped checks yield
false and the unskipped checks yield true. This option comes handy
when one want to observe the executions that fail one (or several) checks
while passing others. Default is \opt{false}.

\item[{\tt -optace <bool>}] Optimise the axiomatic candidate execution stage.
When enabled by \opt{-optace true},  \herd{} does not generate candidate
executions that fail the uniproc test. The default is ``\opt{true}''
for internal models (except the minimal model), and ``\opt{false}'' for
text file models. Notice that \opt{-model uniproc.cat}
and \opt{-model minimal.cat -optace true} should yield identical results,
the second being faster.
Setting \opt{-optace true} can lower the execution time significantly,
but one should pay attention not to design models that forget the uniproc
condition.

\item[{\tt \aname{opt:show}{-show} (prop|neg|all|cond|wit|none)}]
Select execution diagrams for picture display and generation.
Execution diagrams are shown according to
the final condition of test. The final condition is a quantified boolean
proposition \verb+exists +$p$, \verb+~exists +$p$, or \verb+forall +$p$.
The semantics of recognised tags is as follows:
\begin{itemize}
\item \opt{prop} Picture executions for which $p$ is true.
\item \opt{neg} Picture executions for which $p$ is false.
\item \opt{all}  Picture all executions.
\item \opt{cond} Picture executions that validate  the condition,
\emph{i.e.} $p$ is true for \verb+exists+ and \verb+forall+, and false
for \verb+~exists+.
\item \opt{wit} Picture ``\emph{interesting}'' executions,
\emph{i.e.} $p$ is true for \verb+exists+ and \verb+~exists+,
and false for \verb+forall+.
\item \opt{none} Picture no  execution.
\end{itemize}
Default is \opt{none}.

\item[{\tt \aname{opt:initwrites}{-initwrites} <bool>}]
Represent init writes as plain write events, default is \opt{false} except
for specifically tagged generic models --- see ``Model options''
in Sec.~\ref{language:model}.


\end{description}

\paragraph*{Discard some observations}
Those options intentionally omit some of the final states that \herd{} would
normally generate.

\begin{description}
\item[{\tt -speedcheck (false|true|fast)}] 
When enabled by \opt{-speedcheck true}
or \opt{-speedcheck fast}, attempt to settle the test condition.
That is, \herd{} will
generate a subset of executions (those named ``\emph{interesting}'' above)
in place of all executions.
With setting \opt{-speedcheck fast},
\herd{} will additionally stop as soon as a condition \verb+exists +$p$ is validated, and as soon as a condition \verb+~exists +$p$ or
\verb+forall +$p$ is invalidated. Default is \opt{false}.

\item[{\tt -nshow <int>}]
Stop once \verb+<int>+ pictures have been collected. Default is to
collect all (specified, see option \ahrefloc{opt:show}{\opt{-show}}) pictures.
\end{description}

\paragraph*{Control \texttt{dot} pictures}
These options control the content of DOT images.

We first describe options that act at the general level.
\begin{description}
\item[{\tt -graph (cluster|free|columns)}] Select main mode for graphs.
See Sec.~\ref{mode:example}. The default is \opt{cluster}.
\item[{\tt -dotmode (plain|fig)}] The setting \opt{-dotmode fig}
produces output that includes the proper escape
sequence for translating \texttt{.dot} files
to \texttt{.fig} files (\emph{e.g.} with \texttt{dot -Tfig\ldots}).
Default is \opt{plain}.
\item[{\tt -dotcom (dot|neato|circo)}] Select the command that formats
graphs displayed by the \ahrefloc{opt:gv}{\opt{-gv}} option.
The default is \opt{dot} for the \opt{cluster} and~\opt{free} graph modes,
and \opt{neato} for the \opt{columns} graph mode.

\item[{\tt -showevents (all|mem|noregs)}] Control which events are
pictured:
\begin{itemize}
\item \opt{all} Picture all events.
\item \opt{mem} Picture memory events.
\item \opt{noregs} Picture all events except register events,
\emph{i.e.} memory, fences and branch events.
\end{itemize}
Default is \opt{noregs}.

\item[{\tt -showinitwrites <bool>}] Show initial write events
(when existing, see option~\ahrefloc{opt:initwrites}{-initwrites})
in pictures. Default is \opt{true}.

\item[{\tt -mono <bool>}] The setting \opt{-mono true} commands monochrome
pictures. This option acts upon default color selection. Thus, it
has no effect on colors given explicitely with the
\ahrefloc{opt:edgeattr}{\opt{-edgeattr}} option.

\item[{\tt -scale <float>}]
Global scale factor for graphs in \opt{columns} mode.
Default is \opt{1.0}.
\item[{\tt -xscale <float>}]
Global scale factor for graphs in \opt{columns} mode, x direction.
Default is \opt{1.0}.
\item[{\tt -yscale <float>}]
Global scale factor for graphs in \opt{columns} mode, y direction.
Default is \opt{1.0}.
\item[{\tt -showthread <bool>}] Show thread numbers in figures.
In \opt{cluster} mode where the events of a thread are clustered,
thread cluster have a label.
In \opt{free} mode \textrel{po} edges are suffixed by a thread number.
In \opt{columns} mode,  columhs have a header node that shows
the thread number. Default is~\opt{true}.
\item[{\tt -texmacros <bool>}] Use latex commands in some text of pictures.
If activated (\opt{-showthread true}), thread numbers are shown as
\verb+\myth{+$n$\verb+}+. Assembler instructions are locations in nodes
are argument to an \verb+\asm+ command. It user responsability to define
those commands in their \LaTeX{} documents that include the pictures.
Possible definitions are \verb+\newcommand{\myth}[1]{Thread~#1}+
and \verb+\newcommand{\asm}[1]{\texttt{#1}}+.
Default is~\opt{false}.
\end{description}

A few options control picture legends.
\begin{description}
\item[{\tt -showlegend <bool>}]
Add a legend to pictures. By default legends show the test name and
a comment from the executed model.
This comment is the first item
of model syntax  --- see Sec~\ref{language:model}.
Default is~\opt{true}.
\item[{\tt -showkind <bool>}]
Show test kind in legend.
The kind derive from the quantifier of test final condition,
kind \texttt{Allow} being \verb+exists+,
kind \texttt{Forbid} being \verb+~exists+,
and kind \texttt{Require} being \verb+forall+.
Default is~\opt{false}.
\item[{\tt -shortlegend <bool>}]
Limit legend to test name. Default is~\opt{false}.
\end{description}

A few options control what is shown in nodes
and on their sizes, \emph{i.e.}
on how events are pictured.
\begin{description}
\item[{\tt -squished <bool>}] The setting \opt{-squished true} drastically
limits the information displayed in graph nodes. This is usually what
is wanted in modes \opt{free} and~\opt{columns}. Default is~\opt{false}.
\item[{\tt -fixedsize <bool>}] This setting is meaningfull in
\opt{columns} graph mode and for squished nodes. When set by
\opt{-fixedsize true} it forces node width to be $65\%$ of the space
between columns. This may sometime yield a nice edge routing. Default is~\opt{false}
\item[{\tt -extrachars <float>}] This setting is meaningful in
\opt{columns} graph mode and for squished nodes.
When the size of nodes is not fixed (\emph{i.e.} \opt{-fixedsize false} and default), \herd{} computes the width of nodes by counting caracters in node
labels and scaling the result by the font size.
The setting \opt{-extrachars~}$v$ commands adding the value $v$ before scaling.
Negative values are of course accepted. Default is \opt{0.0}.
\item[{\tt -showobserved <bool>}] Highlight observed memory read events with
stars ``\texttt{*}''. A memory read is observed when the value it reads
is stored in a register that appears in final states.
Default is~\opt{false}.
\item[{\tt -brackets <bool>}] Show brackets around locations. Default
is~\opt{false}.
\end{description}

Then we list options that offer some control on which edges are shown.
We recall that the main controls over the shown and unshown edges are
the \verb+show+ and \verb+unshow+ directives in model definitions ---
see Sec.~\ref{show:def}.
However, some edges can be controled only with options (or configuration
files) and the \opt{-unshow} option proves convenient.
\begin{description}
\item[{\tt -showpo <bool>}] Show program order (\textrel{po}) edges.
Default is~\opt{true}.
Default is~\opt{false}.
\item[{\tt -showinitrf <bool>}] Show read-from edges from initial state.
Default is~\opt{false}.
\item[{\tt -showfinalrf <bool>}] Show read-from edges to the final state,
\emph{i.e} show the last store to locations. Default is~\opt{false}.
\emph{i.e} show the last store to locations. Default is~\opt{false}.
\item[{\tt -showfr <bool>}] Show from-read edges. Default is~\opt{true}.
\item[{\tt -doshow <\textit{name}$_1$,\ldots,\textit{name}$_n$>}]
Do show edges labelled with \textit{name}$_1$,\ldots,\textit{name}$_n$.
This setting applies when names are bound in model definition.
\item[{\tt -unshow <\textit{name}$_1$,\ldots,\textit{name}$_n$>}]
Do not show edges labelled with \textit{name}$_1$,\ldots,\textit{name}$_n$.
This setting applies at the very last momement and thus cancels any
\verb+show+ directive in model definition and any \opt{-doshow} command
line~option.
\end{description}
Other options offer some control over some of the attributes defined in
\ahref{\urlgraphviz}{Graphviz software} documentation.
Notice that the controlled attributes are omitted from DOT files
when no setting is present.
For instance in the absence of a \opt{-spline <tag>} option, \herd{}
will generate no definition for the \texttt{splines} attribute thus
resorting to DOT tools defaults.
Most of the following
options accept the \opt{none}~argument that restores their
default behaviour.
\begin{description}
\item[{\tt -splines (spline|true|line|false|polyline|ortho|curved|none)}]
Define the value of the \texttt{splines} attribute. Tags are replicated in
output files as the value of the attribute, except for \opt{none}.
\item[{\tt -margin <float|none>}] Specifies the \texttt{margin} attribute of graphs.
\item[{\tt -pad <float|none>}] Specifies the \texttt{pad} attribute of graphs.
\item[{\tt -sep <string|none>}] Specifies the \texttt{sep} attribute of graphs.
Notice that the argument is an arbitray string, so as to allow DOT general
syntax for this attribute.
\item[{\tt -fontname <string|none>}] Specifies the graph fontname attribute.
\item[{\tt -fontsize <int|none>}] Specifies the fontsize attribute~$n$ of all
text in the graph.
\item[{\tt -edgefontsizedelta <int>}] option \opt{-edgefontsizedelta }$m$ sets
the fontsize attributes of edges to $n+m$, where $n$ is the argument to
the \opt{-fontsize} option. Default is \opt{0}. This option has  no effect if
fontsize is unset.
\item[{\tt -penwidth <float|none>}] Specifies the \texttt{penwidth} attribute of
edges.
\item[{\tt -arrowsize <float|none>}] Specifies the \texttt{arrowsize}
attribute of edges.
\item[{\tt \aname{opt:edgeattr}{-edgeattr} <label,attribute,value>}]
Give value \opt{value} to attribute \opt{attribute}  of all edges labelled
\opt{label}. This powerful option  permits alternative styles for edges.
For instance, the \textrel{ghb} edges of the diagrams of this document
are thick purple (blueviolet) arrows thanks to the settings:
\opt{-edgeattr ghb,color,blueviolet}
\opt{-edgeattr ghb,penwidth,3.0}
\opt{-edgeattr ghb,arrowsize,1.2}. Notice that the settings performed
by the \opt{-edgeattr} option override other settings.
This option has no default.
\end{description}

\paragraph*{Change input}
Those options are the same as the ones
of~\litmus{} --- see Sec.~\ref{change:input}.

\begin{description}
\item[{\tt -names <file>}] Run \herd{} only on tests whose names are
listed in \texttt{<file>}.
\item[{\tt -rename <file>}] Change test names.
\item[{\tt -kinds <file>}] Change test kinds.
This amonts to changing the quantifier of final conditions, with
kind \texttt{Allow} being \verb+exists+,
kind \texttt{Forbid} being \verb+~exists+
and kind \texttt{Require} being \verb+forall+.
\item[{\tt -conds <file>}] Change the final condition of tests.
This is by far the most useful of these options:
in combination with option \opt{-show prop} it permits a fine grain
selection of execution pictures --- see Sec.~\ref{example:invalid}.
\end{description}

\subsection{\label{herd:configfile}{Configuration files}}
The syntax of configuration files is minimal:
lines ``\textit{key} \textit{arg}'' are interpreted
as setting the value of parameter~\textit{key} to \textit{arg}.
Each parameter has a corresponding option,
usually \opt{-}\textit{key}, except for the single letter
option \opt{-v} whose parameter is \opt{verbose}.

As command line option are processed left-to-right,
settings from a configuration file (option \opt{-conf})
can be overridden by a later command line option.
Configuration files will be used mostly for controling pictures.
Some configuration files are
are present in the distribution.
As an example, here is the configuration file \afile{apoil.cfg},
which can be used to display images in \opt{free} mode.
\verbatiminput{apoil.cfg}
The configuration above is commented with line comments that starts
with ``\verb+#+''.
The above configuration file comes handy to eye-proof model output,
even for relatively complex tests, such as \atest{IRIW+lwsyncs}
and \atest{IRIW+syncs}:
\begin{verbatim}
% herd -conf apoil.cfg -show prop -gv IRIW+lwsyncs.litmus
% herd -through invalid -conf apoil.cfg -show prop -gv IRIW+syncs.litmus
\end{verbatim}
We run the two tests on top of the default model that computes,
amongst others, a \texttt{prop} relation. The model rejects executions
with a cyclic \textrel{prop}.
One can then see that the relation \textrel{prop} is acyclic
for \ltest{IRIW+lwsyncs} and cyclic for \ltest{IRIW+syncs}:
\begin{center}\img{IRIW+lwsyncs+APOIL}\quad\quad\img{IRIW+syncs+APOIL}\end{center}
Notice that we used the option~\opt{-through invalid} in the case
of \ltest{IRIW+syncs} as we would otherwise have no image.


\subsection{\label{herd:searchpath}File searching}
Configuration and model files are searched first in the current directory;
then in any directory specified
by setting the shell environment variable \texttt{HERDDIR};
and then in herd installation directory, which is defined
while compiling~\herd.

\section{Extensions to Herd}

\begin{quote}\it
This section describes several extensions to \herd{} that have been implemented by Tyler Sorensen and John Wickerson in collaboration with the original authors. In due course, the contents of this section will probably be merged into the previous sections to form a cohesive manual.
\end{quote}

\subsection{Additional command line options}

\begin{description}
\item[{\tt \aname{opt:dumplem}{-dumplem}}] Convert the given herd model to Lem format, and exit. The resultant Lem file is generated on {\tt stdout}. 
\begin{quote}\emph{Note.} It is necessary to provide a litmus test when invoking \herd{} in this way, even though the litmus test will not be examined. This is due to a minor technical problem.\end{quote}
\item[{\tt \aname{opt:evince}{-evince}}] Fork the evince document viewer to display execution diagrams. This option was implemented to provide an alternative to the {\tt gv} viewer.
\end{description}



\subsection{Curried function application}

\begin{quote}\it 
This is an amendment to Section~\ref{language:expression}.
\end{quote}

The syntax of expressions with respect to function application is currently described as:
\begin{syntax}
\nt{expr} \is{} \dots 
\alt \NT{id} \T{(} \NT{args} \T{)}
\end{syntax}

In fact, the syntax is more general: multiple arguments may be given, in a currying fashion. For instance, one may write such expressions as {\tt f (a,b) (c,d,e)}. The syntax should therefore be updated as follows:
\begin{syntax}
\nt{expr} \is{} \dots 
\alt \NT{id} \brepet \T{(} \NT{args} \T{)} \erepet
\end{syntax}

\subsection{Expressions over sets}

\begin{quote}\it
This is an appendix to Section~\ref{language:expression}.
\end{quote}

Models can now define expressions over sets, and also bind identifiers to sets. The syntax of expressions thus becomes:

\begin{syntax}
\nt{expr} \is{} \ldots
\alt \T{\{\}}
\alt \T{\_}
\alt \T{\textasciitilde}\NT{expr} 
\alt \T{!}\NT{expr} 
\alt \NT{expr} \T{*} \NT{expr}
\alt \T{[} \NT{expr} \T{]}
\end{syntax}

We write \synt{\T{\{\}}} for the empty set (in contrast to \synt{\T{0}} for the empty relation), \synt{\T{\_}} for the universal set of all events in the event structure, \synt{\T{\textasciitilde}} for the complement of a relation, and \synt{\T{!}} for the complement of a set. If $s$ and $t$ represent sets, then \synt{\text{$s$} \T{*} \text{$t$}} builds their cross product. We also provide \synt{\T{[} \text{$s$} \T{]}}, which denotes the relation that links each element of $s$ to itself.

\subsection{Provided conditions and undefined-unless conditions}

\begin{quote}\it
This is an appendix to Section~\ref{language:instruction}.
\end{quote}

A test-instruction is used to enforce a contract between the programming language and the programmer. There are two types: \emph{provided conditions} and \emph{undefined-unless conditions}. The latter are indicated with the \synt{\T{undefined\_unless}} keyword. A provided condition is an obligation on the programming language; that is, the programmer can assume that every execution of their program will satisfy every provided condition. An undefined-unless condition is an obligation on the programmer; that is, the compiler-writer can assume that every execution of the program will satisfy every undefined-unless condition. In other words, if a program has an execution that violates an undefined-unless condition, then its behaviour is completely undefined.

The syntax for instructions thus becomes:

\begin{syntax}
\nt{instruction} \is{} \ldots
\alt \T{undefined\_unless} \NT{check} \NT{expr} \boption \T{as} \NT{id}\eoption
\end{syntax}

\subsection{Additional identifiers}

\begin{quote}\it
This is an appendix to Section~\ref{language:identifier}.
\end{quote}

\paragraph*{Pre-defined relations}

Here are some more pre-defined relations.
\begin{idtable}
{\tt unv}    & universal relation & relates every event in the structure to every other event \\
{\tt int-$s$} & internal at given scope & \emph{(applicable only to scoped memory models)} relates events that are in the same part of the execution hierarchy \\
{\tt ext-$s$} & external at given scope & \emph{(applicable only to scoped memory models)} relates events that are in different parts of the execution hierarchy \\
\end{idtable}
Here, $s$ ranges over the following values:

\begin{center}
\begin{tabular}{ll}
value of $s$ & description (in OpenCL terminology) \\ 
\hline
{\tt wi}, {\tt thread} & work-item \\
{\tt sg}, {\tt warp} & sub-group \\
{\tt wg}, {\tt block}, {\tt cta} & work-group \\
{\tt kernel} & kernel \\
{\tt dev} & device \\
\end{tabular}
\end{center}

For example, {\tt int-cta} relates all events that are in the same work-group, while {\tt ext-wi} relates all events that are in different work-items (threads).

We provide the following additional fence relations: \verb"membar.cta", \verb"membar.gl", \verb"membar.sys" (PTX). C++ and OpenCL fences do not appear in this list because those fences are modelled as events rather than relations. By modelling these fences as events, we are better able to attach parameters to them, such as the memory-order (C++ and OpenCL) and the memory-scope (OpenCL).

In C++ models, the following relations are pre-defined.
\begin{idtable}
{\tt asw}    & additional synchronises-with & links every initial write to every event that is not an initial write \\
{\tt lo}     & lock order & a total order on all mutex operations (similar to {\tt co}, but for mutexes instead of writes) \\
\end{idtable}

\paragraph*{Pre-defined sets}
Here are some pre-defined sets, available in all models.
\begin{idtable}
{\tt \_}    & universal set & the set of all events in the structure \\
{\tt R} & read events & set of all reads from memory \\
{\tt W} & write events & set of all writes to memory \\
{\tt M} & memory events & set of all reads from and writes to memory \\
{\tt B} & barrier events & is a barrier \\
{\tt A} & atomic events & is an atomic event \\
{\tt P} & plain events & is not an atomic event \\
{\tt I} & initial writes & is an initial write event \\
\end{idtable}

Having defined these sets, it is now possible to write expressions of the form {\tt RW($e$)} as {\tt [R * W] \& $e$}. However, the simulation in the latter case may be less efficient, owing to the need to construct the intermediate relation {\tt [R * W]}.

In C++ and OpenCL models, the following sets are pre-defined.

\begin{idtable}
{\tt rmw} & read-modify-writes & the set of all read-modify-write events \\
{\tt brmw} & blocked read-modify-writes & events representing an attempted read-modify-write operation that has become stuck \\
{\tt F} & fences & the set of all fences \\
{\tt acq} & acquire & atomic events with ``acquire'' memory-order \\
{\tt rel} & release & atomic events with ``release'' memory-order \\
{\tt acq\_rel} & acquire/release & atomic events with ``acquire/release'' memory-order \\
{\tt rlx} & relaxed & atomic events with ``relaxed'' memory-order \\
{\tt sc} & sequentially consistent & atomic events with ``sequentially consistent'' memory-order \\
{\tt na} & non-atomics & non-atomic events \\
\end{idtable}

In C++ models, the following sets are pre-defined.

\begin{idtable}
{\tt lk} & locks & the set of all lock events \\
{\tt ls} & successful locks & the set of all successful lock events \\
{\tt ul} & unlocks & the set of all unlock events \\
{\tt con} & consume & atomic events with ``consume'' memory-order \\
{\tt atomicloc} & atomic locations & events acting on atomic locations \\
{\tt nonatomicloc} & non-atomic locations & events acting on non-atomic locations \\
{\tt mutexloc} & mutex locations & events acting on mutex locations \\
\end{idtable}

In OpenCL models, the following sets are pre-defined.

\begin{idtable}
{\tt gF} & global fences & the set of all global fences \\
{\tt lF} & local fences & the set of all local fences \\
{\tt wi} & work-item scope & events with ``work-item'' memory-scope \\ 
{\tt sg} & sub-group scope & events with ``sub-group'' memory-scope \\ 
{\tt wg} & work-group scope & events with ``work-group'' memory-scope \\ 
{\tt dev} & device scope & events with ``device'' memory-scope \\ 
{\tt all\_dev} & all-devices scope & events with ``all\_svn\_devices'' memory-scope \\ 
\end{idtable}



